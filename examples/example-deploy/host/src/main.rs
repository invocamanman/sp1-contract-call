use alloy::hex;
use alloy_primitives::{address, Address, Bytes, B256};
use alloy_provider::ReqwestProvider;
use alloy_rpc_types::BlockNumberOrTag;
use sp1_cc_client_executor::ContractInputCalldata;
use sp1_cc_host_executor::HostExecutor;
use sp1_sdk::utils;
use url::Url;

#[tokio::main]
async fn main() -> eyre::Result<()> {
    // Intialize the environment variables.
    dotenv::dotenv().ok();

    // Setup logging.
    utils::setup_logger();

    // Prepare the host executor.
    //
    let block_number = BlockNumberOrTag::Latest;

    // Use `ETH_SEPOLIA_RPC_URL` to get all of the necessary state for the smart contract call.
    let rpc_url = std::env::var("ETH_SEPOLIA_RPC_URL")
        .unwrap_or_else(|_| panic!("Missing ETH_SEPOLIA_RPC_URL in env"));
    let provider = ReqwestProvider::new_http(Url::parse(&rpc_url)?);
    let mut host_executor = HostExecutor::new(provider.clone(), block_number).await?;

    // Keep track of the block hash. Later, validate the client's execution against this.
    let bytes = hex::decode("608060405234801561000f575f80fd5b5060405161047b38038061047b833981810160405281019061003191906102f9565b5f5b81518110156100f0575f8373ffffffffffffffffffffffffffffffffffffffff1663257b363284848151811061006c5761006b610353565b5b60200260200101516040518263ffffffff1660e01b8152600401610090919061038f565b6020604051808303815f875af11580156100ac573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906100d091906103db565b036100dd575f805260205ff35b80806100e890610433565b915050610033565b5060015f5260205ff35b5f604051905090565b5f80fd5b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6101348261010b565b9050919050565b5f6101458261012a565b9050919050565b6101558161013b565b811461015f575f80fd5b50565b5f815190506101708161014c565b92915050565b5f80fd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b6101c08261017a565b810181811067ffffffffffffffff821117156101df576101de61018a565b5b80604052505050565b5f6101f16100fa565b90506101fd82826101b7565b919050565b5f67ffffffffffffffff82111561021c5761021b61018a565b5b602082029050602081019050919050565b5f80fd5b5f819050919050565b61024381610231565b811461024d575f80fd5b50565b5f8151905061025e8161023a565b92915050565b5f61027661027184610202565b6101e8565b905080838252602082019050602084028301858111156102995761029861022d565b5b835b818110156102c257806102ae8882610250565b84526020840193505060208101905061029b565b5050509392505050565b5f82601f8301126102e0576102df610176565b5b81516102f0848260208601610264565b91505092915050565b5f806040838503121561030f5761030e610103565b5b5f61031c85828601610162565b925050602083015167ffffffffffffffff81111561033d5761033c610107565b5b610349858286016102cc565b9150509250929050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b61038981610231565b82525050565b5f6020820190506103a25f830184610380565b92915050565b5f819050919050565b6103ba816103a8565b81146103c4575f80fd5b50565b5f815190506103d5816103b1565b92915050565b5f602082840312156103f0576103ef610103565b5b5f6103fd848285016103c7565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f61043d826103a8565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361046f5761046e610406565b5b60018201905091905056fe000000000000000000000000ba36ee0dbdc8fe4c2f82dd75506cf836e020597400000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001ed9965253b7a9d2c372fa2b3f4e3c9de35a70698a4e47e856f6472bebfd53a17").expect("Decoding failed");
    println!("Checking injectedGERs on L1");
    let check_injected_gers_existance = host_executor
        .executeCalldata(ContractInputCalldata {
            contract_address: address!("0000000000000000000000000000000000000000"),
            caller_address: address!("0000000000000000000000000000000000000000"),
            calldata: Bytes::from(bytes),
        })
        .await?;

    Ok(())
}
